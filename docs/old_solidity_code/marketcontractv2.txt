// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Import the contracts/interfaces we need
import "./OutcomeToken.sol";
import "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts@5.0.2/access/Ownable.sol";

/**
 * @title MarketV2
 * @notice This contract manages a single prediction market.
 * It is 'Ownable' (by the Factory), but has a 'resolver' (the user)
 * who can resolve the market.
 */
contract MarketV2 is Ownable {

    // --- State Variables ---

    string public question;
    address public resolver; // The user who can resolve the market
    
    IERC20 public collateralToken;  // The mUSDC contract
    OutcomeToken public yesToken;     // The deployed "YES" token
    OutcomeToken public noToken;      // The deployed "NO" token

    bool public marketResolved = false;
    bool public outcomeWasYes;
    
    // AMM Pool Addresses
    address public yesPoolAddress;
    address public noPoolAddress;

    // --- Constants ---

    // Scaling factor to convert 6-decimal USDC to 18-decimal outcome tokens
    // 10 ** (18 - 6) = 10 ** 12
    uint constant private SCALING_FACTOR = 10 ** 12;

    // --- Events ---
    event Mint(address indexed user, uint amount);
    event Resolve(bool indexed outcome);
    event RedeemWinnings(address indexed user, uint amount);
    event PoolsSet(address yesPool, address noPool);

    // --- Functions ---

    /**
     * @notice Deployed by the Factory. Sets up the market and creates tokens.
     * @param _question The market's prediction question.
     * @param _creator The user's address (who becomes the 'resolver').
     * @param _collateralAddress The address of the mUSDC contract.
     */
    constructor(
        string memory _question,
        address _creator,
        address _collateralAddress
    ) Ownable(msg.sender) { // The Factory becomes the 'owner'
        question = _question;
        resolver = _creator; // The user is the 'resolver'
        collateralToken = IERC20(_collateralAddress);

        // 1. Deploy the two new outcome tokens
        yesToken = new OutcomeToken(
            string.concat("YES-", _question), "YES"
        );
        noToken = new OutcomeToken(
            string.concat("NO-", _question), "NO"
        );

        // 2. CRITICAL: Transfer ownership of the new tokens TO THIS CONTRACT
        // This allows this MarketV2 contract to call mint() and burn()
        yesToken.transferOwnership(address(this));
        noToken.transferOwnership(address(this));
    }

    /**
     * @notice Mints a full set of (1 YES + 1 NO) tokens
     * in exchange for 1 unit of collateral (mUSDC).
     * This is the core arbitrage function.
     * @param usdcAmount The amount of USDC (in 6-decimal units) to deposit.
     */
    function mint(uint usdcAmount) public {
        require(!marketResolved, "Market is resolved");

        // Convert 6-decimal USDC amount to 18-decimal outcome token amount
        uint outcomeAmount = usdcAmount * SCALING_FACTOR;

        // 1. Pull mUSDC from the user's wallet into this contract
        // (User must have called 'approve' on mUSDC contract first)
        bool sent = collateralToken.transferFrom(msg.sender, address(this), usdcAmount);
        require(sent, "Collateral transfer failed");

        // 2. Mint 1:1 YES and NO tokens directly to the user
        yesToken.mint(msg.sender, outcomeAmount);
        noToken.mint(msg.sender, outcomeAmount);

        emit Mint(msg.sender, outcomeAmount);
    }

    /**
     * @notice Resolves the market. Only the 'resolver' (creator) can do this.
     * @param _outcomeWasYes The final, real-world result.
     */
    function resolveMarket(bool _outcomeWasYes) public {
        require(msg.sender == resolver, "Only resolver can call");
        require(!marketResolved, "Market already resolved");

        marketResolved = true;
        outcomeWasYes = _outcomeWasYes;
        emit Resolve(_outcomeWasYes);
    }

    /**
     * @notice Redeems winning tokens for collateral AFTER resolution.
     * @param amount The amount of WINNING tokens (18 decimals) to redeem.
     */
    function redeemWinnings(uint amount) public {
        require(marketResolved, "Market not resolved");
        
        // Determine which token won
        OutcomeToken winningToken = outcomeWasYes ? yesToken : noToken;
        
        // 1. Burn the winning tokens from the user's wallet
        // (User must have called 'approve' on the winning token contract first)
        winningToken.burn(msg.sender, amount);
        
        // 2. Send them the equivalent amount of collateral (mUSDC)
        // Convert 18-decimal token amount back to 6-decimal USDC amount
        uint usdcAmount = amount / SCALING_FACTOR;
        bool sent = collateralToken.transfer(msg.sender, usdcAmount);
        require(sent, "Collateral transfer failed");

        emit RedeemWinnings(msg.sender, amount);
    }

    /**
     * @notice The resolver calls this ONCE after creating the Uniswap pools.
     * This links the market to its AMM prices.
     * @param _yesPool The address of the YES/mUSDC Uniswap pool.
     * @param _noPool The address of the NO/mUSDC Uniswap pool.
     */
    function setPoolAddresses(address _yesPool, address _noPool) public {
        require(msg.sender == resolver, "Only resolver can call");
        require(yesPoolAddress == address(0), "Pools already set"); // Can only be set once
        
        yesPoolAddress = _yesPool;
        noPoolAddress = _noPool;
        
        emit PoolsSet(_yesPool, _noPool);
    }
}